const { db } = require('../connection');
const { getNextTradingDay, isTradingDay } = require('../../utils/tradingCalendar');

// ‰∫§ÊòìËÆ°ÂàíÁõ∏ÂÖ≥Êï∞ÊçÆÂ∫ìÊìç‰Ωú
const tradingPlanModel = {
    // ÂàõÂª∫‰∫§ÊòìËÆ°Âàí
    create: (userId, planData) => {
        return new Promise((resolve, reject) => {
            try {
                const currentTime = new Date().toISOString();
                const {
                    stock_code, stock_name, plan_type, plan_date,
                    target_price, current_price, stop_profit_price, stop_loss_price,
                    quantity, estimated_amount, reason, notes, priority,
                    alert_enabled, alert_range
                } = planData;

                const info = db.prepare(`INSERT INTO trading_plans
                    (user_id, stock_code, stock_name, plan_type, plan_status, target_price, current_price,
                     stop_profit_price, stop_loss_price, quantity, estimated_amount, plan_date, created_at,
                     reason, notes, priority, alert_enabled, alert_range)
                    VALUES (?, ?, ?, ?, 'pending', ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(
                    userId, stock_code, stock_name, plan_type, target_price, current_price || null,
                    stop_profit_price || null, stop_loss_price || null, quantity || null,
                    estimated_amount || null, plan_date, currentTime, reason || null, notes || null,
                    priority || 3, alert_enabled !== false ? 1 : 0, alert_range || 0.02
                );

                resolve({ id: info.lastInsertRowid, created_at: currentTime });
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñÁî®Êà∑ÁöÑÊâÄÊúâËÆ°ÂàíÔºàÂ∏¶Á≠õÈÄâÂíåÂàÜÈ°µÔºâ
    findByUserId: (userId, filters = {}) => {
        return new Promise((resolve, reject) => {
            try {
                const { status, planType, stockCode, startDate, endDate, limit = 100, offset = 0 } = filters;

                let query = 'SELECT * FROM trading_plans WHERE user_id = ?';
                const params = [userId];

                if (status) {
                    query += ' AND plan_status = ?';
                    params.push(status);
                }
                if (planType) {
                    query += ' AND plan_type = ?';
                    params.push(planType);
                }
                if (stockCode) {
                    query += ' AND stock_code = ?';
                    params.push(stockCode);
                }
                if (startDate) {
                    query += ' AND plan_date >= ?';
                    params.push(startDate);
                }
                if (endDate) {
                    query += ' AND plan_date <= ?';
                    params.push(endDate);
                }

                query += ' ORDER BY plan_date DESC, priority DESC, created_at DESC LIMIT ? OFFSET ?';
                params.push(limit, offset);

                const rows = db.prepare(query).all(...params);
                resolve(rows);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑Âèñ‰ªäÊó•ËÆ°ÂàíÔºàÂÆûÈôÖ‰∏∫‰∏ã‰∏Ä‰∏™‰∫§ÊòìÊó•ÁöÑËÆ°ÂàíÔºâ
    getTodayPlans: (userId) => {
        return new Promise((resolve, reject) => {
            try {
                // Âà§Êñ≠‰ªäÂ§©ÊòØÂê¶‰∏∫‰∫§ÊòìÊó•
                const now = new Date();
                const today = now.toISOString().split('T')[0];
                let targetDate;

                if (isTradingDay(now)) {
                    // Â¶ÇÊûú‰ªäÂ§©ÊòØ‰∫§ÊòìÊó•ÔºåËøîÂõû‰ªäÂ§©ÁöÑËÆ°Âàí
                    targetDate = today;
                } else {
                    // Â¶ÇÊûú‰ªäÂ§©‰∏çÊòØ‰∫§ÊòìÊó•ÔºàÂë®Êú´ÊàñËäÇÂÅáÊó•ÔºâÔºåËøîÂõû‰∏ã‰∏Ä‰∏™‰∫§ÊòìÊó•ÁöÑËÆ°Âàí
                    const nextTradingDay = getNextTradingDay(now);
                    targetDate = nextTradingDay.toISOString().split('T')[0];
                }

                console.log(`üìÖ Ëé∑Âèñ‰∫§ÊòìËÆ°Âàí - ‰ªäÂ§©: ${today}, ÁõÆÊ†áÊó•Êúü: ${targetDate}`);

                const rows = db.prepare(`SELECT * FROM trading_plans
                    WHERE user_id = ? AND plan_date = ? AND plan_status = 'pending'
                    ORDER BY priority DESC, created_at ASC`).all(userId, targetDate);
                resolve(rows);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ê†πÊçÆIDËé∑ÂèñËÆ°Âàí
    findById: (planId) => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare('SELECT * FROM trading_plans WHERE id = ?').get(planId);
                resolve(row);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Êõ¥Êñ∞ËÆ°Âàí
    update: (planId, planData) => {
        return new Promise((resolve, reject) => {
            try {
                const fields = [];
                const values = [];

                const allowedFields = [
                    'stock_code', 'stock_name', 'plan_type', 'plan_date', 'target_price',
                    'current_price', 'stop_profit_price', 'stop_loss_price', 'quantity',
                    'estimated_amount', 'reason', 'notes', 'priority', 'alert_enabled', 'alert_range'
                ];

                allowedFields.forEach(field => {
                    if (planData[field] !== undefined) {
                        fields.push(`${field} = ?`);
                        values.push(planData[field]);
                    }
                });

                if (fields.length === 0) {
                    resolve({ changes: 0 });
                    return;
                }

                values.push(planId);
                const query = `UPDATE trading_plans SET ${fields.join(', ')} WHERE id = ?`;
                const info = db.prepare(query).run(...values);

                resolve({ changes: info.changes });
            } catch (err) {
                reject(err);
            }
        });
    },

    // ÊâßË°åËÆ°Âàí
    execute: (planId, userId, executionData) => {
        return new Promise((resolve, reject) => {
            try {
                const currentTime = new Date().toISOString();
                const { executionType, executionPrice, executionQuantity, notes } = executionData;

                // ÂºÄÂßã‰∫ãÂä°
                const executeTransaction = db.transaction(() => {
                    // 1. Êõ¥Êñ∞ËÆ°ÂàíÁä∂ÊÄÅ‰∏∫Â∑≤ÊâßË°å
                    db.prepare(`UPDATE trading_plans SET plan_status = 'executed', executed_at = ? WHERE id = ?`)
                        .run(currentTime, planId);

                    // 2. Ëé∑ÂèñËÆ°Âàí‰ø°ÊÅØËÆ°ÁÆóÂÅèÂ∑Æ
                    const plan = db.prepare('SELECT * FROM trading_plans WHERE id = ?').get(planId);
                    const executionAmount = executionPrice * executionQuantity;
                    const priceDeviation = ((executionPrice - plan.target_price) / plan.target_price * 100);

                    // 3. ÊèíÂÖ•ÊâßË°åËÆ∞ÂΩï
                    const info = db.prepare(`INSERT INTO plan_executions
                        (plan_id, user_id, execution_type, execution_price, execution_quantity,
                         execution_amount, execution_time, price_deviation, notes)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(
                        planId, userId, executionType, executionPrice, executionQuantity,
                        executionAmount, currentTime, priceDeviation, notes || null
                    );

                    return {
                        executionId: info.lastInsertRowid,
                        plan: plan,
                        execution: {
                            id: info.lastInsertRowid,
                            execution_price: executionPrice,
                            execution_quantity: executionQuantity,
                            execution_amount: executionAmount,
                            price_deviation: priceDeviation,
                            execution_time: currentTime
                        }
                    };
                });

                const result = executeTransaction();
                resolve(result);
            } catch (err) {
                reject(err);
            }
        });
    },

    // ÂèñÊ∂àËÆ°Âàí
    cancel: (planId, reason) => {
        return new Promise((resolve, reject) => {
            try {
                const info = db.prepare(`UPDATE trading_plans
                    SET plan_status = 'cancelled', notes = ?
                    WHERE id = ?`).run(reason || 'Áî®Êà∑ÂèñÊ∂à', planId);
                resolve({ changes: info.changes });
            } catch (err) {
                reject(err);
            }
        });
    },

    // Âà†Èô§ËÆ°Âàí
    delete: (planId) => {
        return new Promise((resolve, reject) => {
            try {
                const info = db.prepare('DELETE FROM trading_plans WHERE id = ?').run(planId);
                resolve({ changes: info.changes });
            } catch (err) {
                reject(err);
            }
        });
    },

    // ÊâπÈáèÊìç‰Ωú
    batchOperate: (planIds, action, reason) => {
        return new Promise((resolve, reject) => {
            try {
                const batchTransaction = db.transaction(() => {
                    let processed = 0;
                    let failed = 0;

                    planIds.forEach(planId => {
                        try {
                            if (action === 'cancel') {
                                db.prepare(`UPDATE trading_plans SET plan_status = 'cancelled', notes = ? WHERE id = ?`)
                                    .run(reason || 'ÊâπÈáèÂèñÊ∂à', planId);
                            } else if (action === 'delete') {
                                db.prepare('DELETE FROM trading_plans WHERE id = ?').run(planId);
                            }
                            processed++;
                        } catch (err) {
                            failed++;
                        }
                    });

                    return { processed, failed };
                });

                const result = batchTransaction();
                resolve(result);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñËÆ°ÂàíÁªüËÆ°
    getStatistics: (userId, days = 30) => {
        return new Promise((resolve, reject) => {
            try {
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - days);
                const startDateStr = startDate.toISOString().split('T')[0];

                // ÊÄªËÆ°ÂàíÊï∞ÂíåÁä∂ÊÄÅÂàÜÂ∏É
                const statusStats = db.prepare(`SELECT plan_status, COUNT(*) as count
                    FROM trading_plans
                    WHERE user_id = ? AND created_at >= ?
                    GROUP BY plan_status`).all(userId, startDateStr);

                // ËÆ°ÂàíÁ±ªÂûãÂàÜÂ∏É
                const typeStats = db.prepare(`SELECT plan_type, COUNT(*) as count
                    FROM trading_plans
                    WHERE user_id = ? AND created_at >= ?
                    GROUP BY plan_type`).all(userId, startDateStr);

                // ÊâßË°åÁªüËÆ°
                const executionStats = db.prepare(`SELECT
                    COUNT(*) as total_executions,
                    AVG(price_deviation) as avg_price_deviation,
                    MAX(price_deviation) as max_positive_deviation,
                    MIN(price_deviation) as max_negative_deviation
                    FROM plan_executions
                    WHERE user_id = ? AND execution_time >= ?`).get(userId, startDateStr);

                resolve({
                    statusStats,
                    typeStats,
                    executionStats
                });
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ê†áËÆ∞ËøáÊúüËÆ°Âàí
    markExpiredPlans: () => {
        return new Promise((resolve, reject) => {
            try {
                const today = new Date().toISOString().split('T')[0];
                const info = db.prepare(`UPDATE trading_plans
                    SET plan_status = 'expired'
                    WHERE plan_status = 'pending' AND plan_date < ?`).run(today);
                resolve({ changes: info.changes });
            } catch (err) {
                reject(err);
            }
        });
    }
};

// ËÆ°ÂàíÊâßË°åËÆ∞ÂΩïÁõ∏ÂÖ≥Êï∞ÊçÆÂ∫ìÊìç‰Ωú
const planExecutionModel = {
    // Ëé∑ÂèñËÆ°ÂàíÁöÑÊâÄÊúâÊâßË°åËÆ∞ÂΩï
    findByPlanId: (planId) => {
        return new Promise((resolve, reject) => {
            try {
                const rows = db.prepare(`SELECT * FROM plan_executions
                    WHERE plan_id = ?
                    ORDER BY execution_time DESC`).all(planId);
                resolve(rows);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñÁî®Êà∑ÁöÑÊâÄÊúâÊâßË°åËÆ∞ÂΩï
    findByUserId: (userId, limit = 50) => {
        return new Promise((resolve, reject) => {
            try {
                const rows = db.prepare(`SELECT pe.*, tp.stock_code, tp.stock_name, tp.plan_type
                    FROM plan_executions pe
                    JOIN trading_plans tp ON pe.plan_id = tp.id
                    WHERE pe.user_id = ?
                    ORDER BY pe.execution_time DESC
                    LIMIT ?`).all(userId, limit);
                resolve(rows);
            } catch (err) {
                reject(err);
            }
        });
    }
};

module.exports = {
    tradingPlanModel,
    planExecutionModel
};
