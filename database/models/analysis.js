const { db } = require('../connection');

// ÊåÅ‰ªìÂàÜÊûêÊä•ÂëäÁõ∏ÂÖ≥Êï∞ÊçÆÂ∫ìÊìç‰Ωú
const analysisReportModel = {
    // ‰øùÂ≠òÂàÜÊûêÊä•ÂëäÔºàËá™Âä®Âà†Èô§Âêå‰∏ÄÂ§©ÁöÑÊóßÊä•ÂëäÔºâ
    save: (userId, analysisContent, portfolioSummary, reportType = 'manual') => {
        return new Promise((resolve, reject) => {
            try {
                const currentTime = new Date().toISOString();
                const summaryJson = JSON.stringify(portfolioSummary);
                const today = currentTime.split('T')[0]; // Ëé∑ÂèñÊó•ÊúüÈÉ®ÂàÜ YYYY-MM-DD

                // ‰ΩøÁî®‰∫ãÂä°ÔºöÂÖàÂà†Èô§ÂΩìÂ§©ÁöÑÊóßÊä•ÂëäÔºåÂÜçÊèíÂÖ•Êñ∞Êä•Âëä
                const saveWithDeduplication = db.transaction(() => {
                    // Âà†Èô§ÂΩìÂ§©ËØ•Áî®Êà∑ÁöÑÊâÄÊúâÊä•Âëä
                    const deleteStmt = db.prepare(`DELETE FROM analysis_reports
                        WHERE user_id = ? AND DATE(created_at) = ?`);
                    const deleteResult = deleteStmt.run(userId, today);

                    if (deleteResult.changes > 0) {
                        console.log(`üóëÔ∏è Âà†Èô§‰∫ÜÁî®Êà∑ ${userId} Âú® ${today} ÁöÑ ${deleteResult.changes} ‰ªΩÊóßÊä•Âëä`);
                    }

                    // ÊèíÂÖ•Êñ∞Êä•Âëä
                    const insertStmt = db.prepare(`INSERT INTO analysis_reports
                        (user_id, analysis_content, portfolio_summary, report_type, created_at)
                        VALUES (?, ?, ?, ?, ?)`);
                    const info = insertStmt.run(userId, analysisContent, summaryJson, reportType, currentTime);

                    return { id: info.lastInsertRowid, created_at: currentTime, deletedCount: deleteResult.changes };
                });

                const result = saveWithDeduplication();
                resolve(result);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñÁî®Êà∑ÁöÑÂàÜÊûêÊä•ÂëäÂàóË°®ÔºàÊåâÊó•ÊúüÂÄíÂ∫èÔºâ
    findByUserId: (userId, limit = 30, offset = 0) => {
        return new Promise((resolve, reject) => {
            try {
                const rows = db.prepare(`SELECT id, report_type, created_at FROM analysis_reports
                    WHERE user_id = ?
                    ORDER BY created_at DESC
                    LIMIT ? OFFSET ?`).all(userId, limit, offset);

                resolve(rows);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ê†πÊçÆIDËé∑ÂèñÂÆåÊï¥ÁöÑÂàÜÊûêÊä•Âëä
    findById: (reportId) => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT * FROM analysis_reports WHERE id = ?`).get(reportId);

                if (row && row.portfolio_summary) {
                    // Â∞ÜJSONÂ≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫ÂØπË±°
                    row.portfolio_summary = JSON.parse(row.portfolio_summary);
                }

                resolve(row);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñÁî®Êà∑ÊúÄÊñ∞ÁöÑÂàÜÊûêÊä•Âëä
    getLatest: (userId) => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT * FROM analysis_reports
                    WHERE user_id = ?
                    ORDER BY created_at DESC
                    LIMIT 1`).get(userId);

                if (row && row.portfolio_summary) {
                    row.portfolio_summary = JSON.parse(row.portfolio_summary);
                }

                resolve(row);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Âà†Èô§ÂàÜÊûêÊä•Âëä
    delete: (reportId) => {
        return new Promise((resolve, reject) => {
            try {
                const info = db.prepare(`DELETE FROM analysis_reports WHERE id = ?`).run(reportId);
                resolve({ changes: info.changes });
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñÊä•ÂëäÊÄªÊï∞
    getCount: (userId) => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT COUNT(*) as count FROM analysis_reports WHERE user_id = ?`).get(userId);
                resolve(row.count);
            } catch (err) {
                reject(err);
            }
        });
    }
};

// ÈõÜÂêàÁ´û‰ª∑ÂàÜÊûêÁõ∏ÂÖ≥Êï∞ÊçÆÂ∫ìÊìç‰Ωú
const callAuctionAnalysisModel = {
    // ‰øùÂ≠òÈõÜÂêàÁ´û‰ª∑ÂàÜÊûê
    save: (analysisDate, analysisContent, marketSummary, analysisType = 'manual') => {
        return new Promise((resolve, reject) => {
            try {
                const currentTime = new Date().toISOString();
                const summaryJson = JSON.stringify(marketSummary);

                const info = db.prepare(`INSERT OR REPLACE INTO call_auction_analysis
                    (analysis_date, analysis_content, market_summary, analysis_type, created_at)
                    VALUES (?, ?, ?, ?, ?)`)
                    .run(analysisDate, analysisContent, summaryJson, analysisType, currentTime);

                resolve({ id: info.lastInsertRowid, created_at: currentTime });
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñÊâÄÊúâÂàÜÊûêËÆ∞ÂΩïÂàóË°®ÔºàÊåâÊó•ÊúüÂÄíÂ∫èÔºâ
    findAll: (limit = 30, offset = 0) => {
        return new Promise((resolve, reject) => {
            try {
                const rows = db.prepare(`SELECT id, analysis_date, analysis_type, created_at FROM call_auction_analysis
                    ORDER BY analysis_date DESC
                    LIMIT ? OFFSET ?`).all(limit, offset);

                resolve(rows);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ê†πÊçÆÊó•ÊúüËé∑ÂèñÂàÜÊûêËÆ∞ÂΩï
    findByDate: (analysisDate) => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT * FROM call_auction_analysis WHERE analysis_date = ?`).get(analysisDate);

                if (row && row.market_summary) {
                    // Â∞ÜJSONÂ≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫ÂØπË±°
                    row.market_summary = JSON.parse(row.market_summary);
                }

                resolve(row);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ê†πÊçÆIDËé∑ÂèñÂÆåÊï¥ÁöÑÂàÜÊûêËÆ∞ÂΩï
    findById: (id) => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT * FROM call_auction_analysis WHERE id = ?`).get(id);

                if (row && row.market_summary) {
                    row.market_summary = JSON.parse(row.market_summary);
                }

                resolve(row);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñÊúÄÊñ∞ÁöÑÂàÜÊûêËÆ∞ÂΩï
    getLatest: () => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT * FROM call_auction_analysis
                    ORDER BY analysis_date DESC
                    LIMIT 1`).get();

                if (row && row.market_summary) {
                    row.market_summary = JSON.parse(row.market_summary);
                }

                resolve(row);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Âà†Èô§ÂàÜÊûêËÆ∞ÂΩï
    delete: (id) => {
        return new Promise((resolve, reject) => {
            try {
                const info = db.prepare(`DELETE FROM call_auction_analysis WHERE id = ?`).run(id);
                resolve({ changes: info.changes });
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñËÆ∞ÂΩïÊÄªÊï∞
    getCount: () => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT COUNT(*) as count FROM call_auction_analysis`).get();
                resolve(row.count);
            } catch (err) {
                reject(err);
            }
        });
    }
};

// ËÇ°Á•®Êé®ËçêÁõ∏ÂÖ≥Êï∞ÊçÆÂ∫ìÊìç‰Ωú
const stockRecommendationModel = {
    // ‰øùÂ≠òËÇ°Á•®Êé®Ëçê
    save: (recommendationDate, recommendationContent, marketData, recommendationType = 'manual') => {
        return new Promise((resolve, reject) => {
            try {
                const currentTime = new Date().toISOString();
                const dataJson = JSON.stringify(marketData);

                const info = db.prepare(`INSERT OR REPLACE INTO stock_recommendations
                    (recommendation_date, recommendation_content, market_data, recommendation_type, created_at)
                    VALUES (?, ?, ?, ?, ?)`)
                    .run(recommendationDate, recommendationContent, dataJson, recommendationType, currentTime);

                resolve({ id: info.lastInsertRowid, created_at: currentTime });
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñÊâÄÊúâÊé®ËçêËÆ∞ÂΩïÂàóË°®ÔºàÊåâÊó•ÊúüÂÄíÂ∫èÔºâ
    findAll: (limit = 30, offset = 0) => {
        return new Promise((resolve, reject) => {
            try {
                const rows = db.prepare(`SELECT id, recommendation_date, recommendation_type, created_at FROM stock_recommendations
                    ORDER BY recommendation_date DESC
                    LIMIT ? OFFSET ?`).all(limit, offset);

                resolve(rows);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ê†πÊçÆÊó•ÊúüËé∑ÂèñÊé®ËçêËÆ∞ÂΩï
    findByDate: (recommendationDate) => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT * FROM stock_recommendations WHERE recommendation_date = ?`).get(recommendationDate);

                if (row && row.market_data) {
                    // Â∞ÜJSONÂ≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫ÂØπË±°
                    row.market_data = JSON.parse(row.market_data);
                }

                resolve(row);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ê†πÊçÆIDËé∑ÂèñÂÆåÊï¥ÁöÑÊé®ËçêËÆ∞ÂΩï
    findById: (id) => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT * FROM stock_recommendations WHERE id = ?`).get(id);

                if (row && row.market_data) {
                    row.market_data = JSON.parse(row.market_data);
                }

                resolve(row);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñÊúÄÊñ∞ÁöÑÊé®ËçêËÆ∞ÂΩï
    getLatest: () => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT * FROM stock_recommendations
                    ORDER BY recommendation_date DESC
                    LIMIT 1`).get();

                if (row && row.market_data) {
                    row.market_data = JSON.parse(row.market_data);
                }

                resolve(row);
            } catch (err) {
                reject(err);
            }
        });
    },

    // Âà†Èô§Êé®ËçêËÆ∞ÂΩï
    delete: (id) => {
        return new Promise((resolve, reject) => {
            try {
                const info = db.prepare(`DELETE FROM stock_recommendations WHERE id = ?`).run(id);
                resolve({ changes: info.changes });
            } catch (err) {
                reject(err);
            }
        });
    },

    // Ëé∑ÂèñËÆ∞ÂΩïÊÄªÊï∞
    getCount: () => {
        return new Promise((resolve, reject) => {
            try {
                const row = db.prepare(`SELECT COUNT(*) as count FROM stock_recommendations`).get();
                resolve(row.count);
            } catch (err) {
                reject(err);
            }
        });
    }
};

module.exports = {
    analysisReportModel,
    callAuctionAnalysisModel,
    stockRecommendationModel
};
